Claude Code Prompt: Dashboard Chapter Loading Optimization (v15)
Task: Optimize dashboard chapter loading from ~15 seconds to < 2 seconds by:

Replacing per-chapter queries with bulk queries
Loading only 4 visible chapters initially
Implementing the "1 back, current, 2 forward" display logic


Part 1: Replace fetchChaptersProgress with Optimized Version
In src/pages/Dashboard.jsx, replace the entire fetchChaptersProgress function (around lines 335-490) with this optimized version:
javascript/**
 * Fetch chapters with progress for carousel - OPTIMIZED
 * Uses bulk queries instead of per-chapter queries
 * Returns only the 4 visible chapters initially for fast load
 * 
 * @param {string} userId - User ID
 * @param {boolean} loadAll - If true, load all 27 chapters (for "View all" mode)
 * @returns {Object} - { chapters, currentChapterIndex, totalChapters }
 */
async function fetchChaptersProgress(userId, loadAll = false) {
  console.time('fetchChaptersProgress')
  
  // BULK QUERY 1: Get all chapters
  const { data: chapters, error: chaptersError } = await supabase
    .from('chapters')
    .select('chapter_id, chapter_number, title')
    .order('chapter_number', { ascending: true })

  if (chaptersError || !chapters || chapters.length === 0) {
    console.error('‚ùå [fetchChaptersProgress] chapters query failed:', chaptersError)
    return { 
      chapters: [{
        chapter_number: 1,
        title: 'Chapter 1',
        introduced: 0,
        total_lemmas: 0,
        isUnlocked: true,
        isNextToUnlock: false
      }],
      currentChapterIndex: 0,
      totalChapters: 1
    }
  }

  // BULK QUERY 2: Get all sentences (to map chapter_id -> sentence_ids)
  const { data: allSentences } = await supabase
    .from('sentences')
    .select('sentence_id, chapter_id')

  // Build chapter_id -> sentence_ids map
  const chapterSentences = {}
  for (const s of allSentences || []) {
    if (!chapterSentences[s.chapter_id]) {
      chapterSentences[s.chapter_id] = []
    }
    chapterSentences[s.chapter_id].push(s.sentence_id)
  }

  // BULK QUERY 3: Get all words with lemma info (excluding stop words)
  const { data: allWords } = await supabase
    .from('words')
    .select('lemma_id, sentence_id, lemmas!inner(is_stop_word)')
    .eq('lemmas.is_stop_word', false)

  // Build sentence_id -> lemma_ids map
  const sentenceLemmas = {}
  for (const w of allWords || []) {
    if (!sentenceLemmas[w.sentence_id]) {
      sentenceLemmas[w.sentence_id] = new Set()
    }
    sentenceLemmas[w.sentence_id].add(w.lemma_id)
  }

  // BULK QUERY 4: Get all phrase occurrences
  const { data: allPhraseOccurrences } = await supabase
    .from('phrase_occurrences')
    .select('phrase_id, sentence_id')

  // Build sentence_id -> phrase_ids map
  const sentencePhrases = {}
  for (const po of allPhraseOccurrences || []) {
    if (!sentencePhrases[po.sentence_id]) {
      sentencePhrases[po.sentence_id] = new Set()
    }
    sentencePhrases[po.sentence_id].add(po.phrase_id)
  }

  // BULK QUERY 5: Get user's introduced lemmas
  const { data: userLemmaProgress } = await supabase
    .from('user_lemma_progress')
    .select('lemma_id')
    .eq('user_id', userId)
    .gte('reps', 1)

  const introducedLemmaIds = new Set((userLemmaProgress || []).map(p => p.lemma_id))

  // BULK QUERY 6: Get user's introduced phrases
  const { data: userPhraseProgress } = await supabase
    .from('user_phrase_progress')
    .select('phrase_id')
    .eq('user_id', userId)
    .gte('reps', 1)

  const introducedPhraseIds = new Set((userPhraseProgress || []).map(p => p.phrase_id))

  // Calculate stats for each chapter in JavaScript
  const chaptersWithProgress = []
  let previousChapterComplete = true

  for (const chapter of chapters) {
    const sentenceIds = chapterSentences[chapter.chapter_id] || []
    
    // Collect unique lemmas and phrases for this chapter
    const chapterLemmaIds = new Set()
    const chapterPhraseIds = new Set()
    
    for (const sentenceId of sentenceIds) {
      const lemmas = sentenceLemmas[sentenceId]
      if (lemmas) {
        for (const lemmaId of lemmas) {
          chapterLemmaIds.add(lemmaId)
        }
      }
      
      const phrases = sentencePhrases[sentenceId]
      if (phrases) {
        for (const phraseId of phrases) {
          chapterPhraseIds.add(phraseId)
        }
      }
    }

    // Count introduced
    let introducedLemmaCount = 0
    for (const lemmaId of chapterLemmaIds) {
      if (introducedLemmaIds.has(lemmaId)) introducedLemmaCount++
    }

    let introducedPhraseCount = 0
    for (const phraseId of chapterPhraseIds) {
      if (introducedPhraseIds.has(phraseId)) introducedPhraseCount++
    }

    const introduced = introducedLemmaCount + introducedPhraseCount
    const total = chapterLemmaIds.size + chapterPhraseIds.size
    const completionRate = total > 0 ? introduced / total : 0

    // Determine unlock state
    const isUnlocked = chapter.chapter_number === 1 || previousChapterComplete
    const isNextToUnlock = !isUnlocked && previousChapterComplete

    chaptersWithProgress.push({
      chapter_number: chapter.chapter_number,
      title: chapter.title,
      introduced,
      total_lemmas: total,
      isUnlocked,
      isNextToUnlock,
      completionRate
    })

    // Update for next iteration (95% threshold to unlock next)
    if (completionRate >= 0.95) {
      previousChapterComplete = true
    } else {
      previousChapterComplete = false
    }
  }

  // Find current chapter: first unlocked with < 100% completion
  let currentChapterIndex = chaptersWithProgress.findIndex(
    ch => ch.isUnlocked && ch.completionRate < 1.0
  )
  
  // Fallback to first chapter if none found
  if (currentChapterIndex === -1) {
    currentChapterIndex = 0
  }

  console.timeEnd('fetchChaptersProgress')
  console.log(`üìö [fetchChaptersProgress] Current chapter: ${currentChapterIndex + 1}, Total: ${chapters.length}`)

  // If loadAll is true, return everything
  if (loadAll) {
    return {
      chapters: chaptersWithProgress,
      currentChapterIndex,
      totalChapters: chapters.length
    }
  }

  // Otherwise, return only the 4 visible chapters
  // Logic: 1 back, current, 2 forward
  // Example: current=2 -> show [1, 2, 3, 4]
  // Example: current=10 -> show [9, 10, 11, 12]
  // Example: current=1 -> show [1, 2, 3, 4]
  // Example: current=27 -> show [24, 25, 26, 27]
  
  const startIndex = Math.max(0, currentChapterIndex - 1)
  const endIndex = Math.min(chaptersWithProgress.length, startIndex + 4)
  const adjustedStartIndex = Math.max(0, endIndex - 4) // Ensure we always show 4 if possible
  
  const visibleChapters = chaptersWithProgress.slice(adjustedStartIndex, adjustedStartIndex + 4)
  
  // Adjust currentChapterIndex relative to visible chapters
  const visibleCurrentIndex = currentChapterIndex - adjustedStartIndex

  return {
    chapters: visibleChapters,
    currentChapterIndex: visibleCurrentIndex,
    totalChapters: chapters.length,
    // Include these for "View all" functionality
    _allChaptersCache: chaptersWithProgress,
    _absoluteCurrentIndex: currentChapterIndex
  }
}

Part 2: Update Dashboard State and Data Loading
Update the loadDashboardData function to handle the new return format and add lazy loading for "View all":
javascript// Add to dashboardData initial state (around line 17-39)
const [dashboardData, setDashboardData] = useState({
  // ... existing fields ...
  chapters: [],
  totalChapters: 0,
  currentChapterIndex: 0,
  allChaptersLoaded: false,
  _allChaptersCache: null,
  _absoluteCurrentIndex: 0
})

// In loadDashboardData, update how chaptersData is handled (around line 75-87)
setDashboardData({
  ...heroStats,
  ...quickActionStats,
  chapters: chaptersData.chapters,
  totalChapters: chaptersData.totalChapters,
  currentChapterIndex: chaptersData.currentChapterIndex,
  allChaptersLoaded: false,
  _allChaptersCache: chaptersData._allChaptersCache,
  _absoluteCurrentIndex: chaptersData._absoluteCurrentIndex,
  activityData: activityData.data,
  currentStreak: activityData.currentStreak,
  bestStreak: activityData.bestStreak,
  dailyTarget: userSettings.dailyTarget,
  forecastData,
  categories: categoryData,
  streak: streakData,
  username: profileData.username
})

// Add a new function for loading all chapters (add after loadDashboardData)
function handleLoadAllChapters() {
  if (dashboardData._allChaptersCache) {
    // Use cached data - instant!
    setDashboardData(prev => ({
      ...prev,
      chapters: prev._allChaptersCache,
      currentChapterIndex: prev._absoluteCurrentIndex,
      allChaptersLoaded: true
    }))
  }
}

Part 3: Update ChapterCarousel Component
Replace src/components/dashboard/ChapterCarousel.jsx with this updated version that handles the new data format:
jsximport { useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { Lock, BookOpen, CheckCircle, ChevronDown, ChevronUp } from 'lucide-react'

/**
 * ChapterCarousel - Collapsible chapter grid with smart defaults
 * 
 * Shows 4 chapters initially: 1 back, current, 2 forward
 * Expands to show all when "View all" is clicked
 */
export default function ChapterCarousel({ 
  chapters = [], 
  totalChapters = 0,
  currentChapterIndex = 0,
  allChaptersLoaded = false,
  onLoadAllChapters,
  loading = false 
}) {
  const navigate = useNavigate()
  const [isExpanded, setIsExpanded] = useState(false)

  if (loading) {
    return (
      <div className="px-4">
        <h2 className="text-lg font-bold text-neutral-900 mb-3">Chapters</h2>
        <div className="grid grid-cols-2 gap-3">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="h-24 bg-neutral-200 rounded-xl animate-pulse" />
          ))}
        </div>
      </div>
    )
  }

  if (chapters.length === 0) {
    return (
      <div className="px-4">
        <h2 className="text-lg font-bold text-neutral-900 mb-3">Chapters</h2>
        <div className="bg-white border border-neutral-100 rounded-xl p-6 text-center text-neutral-500">
          No chapters available yet
        </div>
      </div>
    )
  }

  // Handle expand/collapse
  const handleToggleExpand = () => {
    if (!isExpanded && !allChaptersLoaded && onLoadAllChapters) {
      // Load all chapters when expanding for the first time
      onLoadAllChapters()
    }
    setIsExpanded(!isExpanded)
  }

  // Determine which chapters to show
  const visibleChapters = isExpanded ? chapters : chapters.slice(0, 4)

  return (
    <div className="px-4">
      {/* Header with expand/collapse button */}
      <div className="flex justify-between items-center mb-3">
        <h2 className="text-lg font-bold text-neutral-900">Chapters</h2>
        {totalChapters > 4 && (
          <button
            onClick={handleToggleExpand}
            className="text-primary-500 text-sm font-medium flex items-center gap-1 hover:text-primary-600 transition-colors"
          >
            {isExpanded ? (
              <>
                Show less
                <ChevronUp className="w-4 h-4" />
              </>
            ) : (
              <>
                View all {totalChapters}
                <ChevronDown className="w-4 h-4" />
              </>
            )}
          </button>
        )}
      </div>

      {/* Chapter cards - 2 column grid */}
      <div className="grid grid-cols-2 gap-3">
        {visibleChapters.map((chapter, index) => {
          const progress = chapter.total_lemmas > 0 ? (chapter.introduced / chapter.total_lemmas) : 0
          const isCurrent = index === currentChapterIndex && !isExpanded || 
                           (isExpanded && chapter.isUnlocked && progress < 1.0 && 
                            chapters.findIndex(c => c.isUnlocked && (c.introduced / c.total_lemmas) < 1.0) === index)
          const isCompleted = chapter.isUnlocked && progress >= 0.95

          return (
            <ChapterCard
              key={chapter.chapter_number}
              chapter={chapter}
              isCurrent={isCurrent}
              isCompleted={isCompleted}
              onNavigate={() => {
                if (chapter.isUnlocked) {
                  navigate(`/read/${chapter.chapter_number}`)
                } else if (chapter.isNextToUnlock) {
                  navigate(`/flashcards?chapter=${chapter.chapter_number}`)
                }
              }}
              onStudy={() => navigate(`/flashcards?chapter=${chapter.chapter_number}`)}
            />
          )
        })}
      </div>
    </div>
  )
}

/**
 * Compact chapter card with improved visual states
 */
function ChapterCard({ chapter, isCurrent, isCompleted, onNavigate, onStudy }) {
  const {
    chapter_number,
    title,
    introduced = 0,
    total_lemmas = 1,
    isUnlocked = false,
    isNextToUnlock = false
  } = chapter

  const progress = total_lemmas > 0 ? Math.round((introduced / total_lemmas) * 100) : 0

  // Visual states - softer styling
  const getCardStyles = () => {
    if (isCurrent) {
      return 'bg-white ring-1 ring-primary-200 border border-primary-100 shadow-sm'
    }
    if (isCompleted) {
      return 'bg-white border border-secondary-100 shadow-sm'
    }
    if (isUnlocked) {
      return 'bg-white border border-neutral-100 shadow-sm'
    }
    if (isNextToUnlock) {
      return 'bg-secondary-50 border border-secondary-200 shadow-sm'
    }
    return 'bg-neutral-50 border border-neutral-100'
  }

  const handleClick = () => {
    if (isUnlocked || isNextToUnlock) {
      onNavigate()
    }
  }

  return (
    <div
      onClick={handleClick}
      className={`
        rounded-xl p-3 transition-all duration-150
        ${getCardStyles()}
        ${(isUnlocked || isNextToUnlock) ? 'cursor-pointer hover:shadow-md' : 'cursor-not-allowed opacity-60'}
      `}
    >
      {/* Header - compact */}
      <div className="flex items-start justify-between mb-1.5">
        <div className="flex-1 min-w-0">
          <div className={`text-[10px] font-semibold uppercase tracking-wide ${
            isCurrent ? 'text-primary-600' : isCompleted ? 'text-secondary-600' : 'text-neutral-400'
          }`}>
            {isCurrent ? 'Current' : `Ch. ${chapter_number}`}
          </div>
          <h3 className={`text-sm font-bold truncate ${
            isUnlocked || isNextToUnlock ? 'text-neutral-900' : 'text-neutral-400'
          }`}>
            {title || `Cap√≠tulo ${chapter_number}`}
          </h3>
        </div>

        {/* Status icon - smaller */}
        <div className="flex-shrink-0 ml-1">
          {isCompleted ? (
            <CheckCircle className="w-4 h-4 text-secondary-500" fill="currentColor" />
          ) : isUnlocked ? (
            <BookOpen className="w-4 h-4 text-primary-500" />
          ) : isNextToUnlock ? (
            <Lock className="w-4 h-4 text-secondary-500" />
          ) : (
            <Lock className="w-4 h-4 text-neutral-300" />
          )}
        </div>
      </div>

      {/* Progress bar */}
      <div className="mt-2">
        <div className="flex justify-between text-[10px] mb-1">
          <span className={isUnlocked || isNextToUnlock ? 'text-neutral-500' : 'text-neutral-300'}>
            {introduced}/{total_lemmas}
          </span>
          <span className={`font-bold ${
            isCurrent ? 'text-primary-600' : isCompleted ? 'text-secondary-600' : isNextToUnlock ? 'text-secondary-500' : 'text-neutral-400'
          }`}>
            {progress}%
          </span>
        </div>
        <div className="w-full bg-neutral-200 rounded-full h-1.5">
          <div
            className="h-1.5 rounded-full transition-all duration-300"
            style={{
              width: `${progress}%`,
              backgroundColor: isCurrent ? '#0ea5e9' : isCompleted ? '#f59e0b' : isNextToUnlock ? '#fbbf24' : '#a8a29e'
            }}
          />
        </div>
      </div>

      {/* Single compact action button */}
      {(isUnlocked || isNextToUnlock) && (
        <button
          onClick={(e) => { e.stopPropagation(); isNextToUnlock ? onStudy() : onNavigate() }}
          className={`
            w-full mt-2 py-1.5 text-xs font-semibold rounded-lg transition-colors
            ${isNextToUnlock
              ? 'bg-secondary-500 text-white'
              : isCurrent
                ? 'bg-primary-500 text-white'
                : 'bg-neutral-100 text-neutral-600 hover:bg-neutral-200'
            }
          `}
          style={{
            backgroundColor: isNextToUnlock ? '#f59e0b' : isCurrent ? '#0ea5e9' : undefined
          }}
        >
          {isNextToUnlock ? 'Study' : isCompleted ? 'Review' : 'Continue'}
        </button>
      )}
    </div>
  )
}

Part 4: Update ChapterCarousel Props in Dashboard
In src/pages/Dashboard.jsx, update the ChapterCarousel component usage (around line 135-138):
jsx{/* Chapters */}
<section className="mb-8">
  <ChapterCarousel
    chapters={dashboardData.chapters}
    totalChapters={dashboardData.totalChapters}
    currentChapterIndex={dashboardData.currentChapterIndex}
    allChaptersLoaded={dashboardData.allChaptersLoaded}
    onLoadAllChapters={handleLoadAllChapters}
    loading={loading}
  />
</section>
Make sure handleLoadAllChapters is defined inside the Dashboard component (not outside as a helper function) so it has access to setDashboardData.

Expected Performance Improvement
BeforeAfter~81 sequential queries6 parallel bulk queries~15 seconds load time< 2 seconds load timeAll 27 chapters loadedOnly 4 visible chapters initiallyBlocking UIInstant initial render
Expected Display Logic
Current ChapterVisible Chapters11, 2, 3, 421, 2, 3, 4109, 10, 11, 122624, 25, 26, 272724, 25, 26, 27

This is the complete optimization. Test by refreshing the dashboard and timing how fast the chapters section loads.